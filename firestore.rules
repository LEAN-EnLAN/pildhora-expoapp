rules_version = '2'

service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isSelf(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }

    function getUser(uid) {
      return get(/databases/$(database)/documents/users/$(uid));
    }

    function userRole() {
      return isSignedIn() ? getUser(request.auth.uid).data.role : null;
    }

    function isCaregiver() {
      return userRole() == "caregiver";
    }

    // users collection: allow users to read/write their own document.
    // Caregivers can read any user (needed to see patient info), but only write their own.
    match /users/{uid} {
      allow read: if isSignedIn();
      allow write: if isSignedIn();
      allow update: if isSignedIn();
    }

    // notificationPreferences/{userId}: only that user can read/write.
    match /notificationPreferences/{userId} {
      allow read, write: if isSelf(userId);
    }

    // tasks: caregiver-owned tasks (caregiverId field).
    // Only the caregiver who owns the task can read/write it.
    match /tasks/{taskId} {
      allow read: if isSignedIn() && resource.data.caregiverId == request.auth.uid;
      allow create: if isSignedIn() && request.resource.data.caregiverId == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.caregiverId == request.auth.uid;
    }

    // medications: documents contain patientId and caregiverId.
    // Allow read/write for the patient or caregiver associated with the medication.
    match /medications/{medicationId} {
      // Read: Patient can read their own medications, any authenticated caregiver can read
      allow read: if isSignedIn() &&
        (
          request.auth.uid == resource.data.patientId ||
          isCaregiver()
        );

      // Write: Patient can write their own medications, any authenticated caregiver can write
      allow write: if isSignedIn() &&
        (
          request.auth.uid == request.resource.data.patientId ||
          isCaregiver()
        );
    }

    // intakeRecords: documents contain patientId.
    // Allow patient to read/write their own records.
    // Caregivers may read/update but not delete; this can be refined later to only linked caregivers.
    match /intakeRecords/{intakeId} {
      allow read, create, update: if isSignedIn() &&
        (
          request.auth.uid == resource.data.patientId ||
          request.auth.uid == request.resource.data.patientId ||
          isCaregiver()
        );
      allow delete: if isSignedIn() &&
        (
          request.auth.uid == resource.data.patientId ||
          request.auth.uid == request.resource.data.patientId
        );
    }

    // devices collection: documents include linkedUsers map and primaryPatientId.
    // Device provisioning rules:
    // - Authenticated users can create devices assigned to themselves
    // - Only the device owner (primaryPatientId) can update the device
    // - Device owner and linked caregivers can read the device
    match /devices/{deviceId} {
      // Helper function to check if device is linked to user via deviceLinks
      function isLinkedToDevice(deviceId, userId) {
        return exists(/databases/$(database)/documents/deviceLinks/$(deviceId + '_' + userId));
      }

      // Helper function to validate device creation - simplified for new user provisioning
      function isValidDeviceCreation() {
        let data = request.resource.data;
        // Must have required fields
        return data.keys().hasAll(['id', 'primaryPatientId']) &&
               // Device ID must match document ID
               data.id == deviceId &&
               // User can only create devices for themselves
               data.primaryPatientId == request.auth.uid &&
               // If provisionedBy is set, it must be the current user
               (!data.keys().hasAny(['provisionedBy']) || data.provisionedBy == request.auth.uid);
      }

      // Create: Authenticated users can create devices assigned to themselves
      // This allows new users to provision their first device
      // SIMPLIFIED: Just check authentication and self-assignment
      allow create: if isSignedIn() && 
        request.resource.data.primaryPatientId == request.auth.uid;

      // Update: Only the device owner (primaryPatientId) can update the device
      // Cannot change the primaryPatientId
      allow update: if isSignedIn() && 
        resource.data.primaryPatientId == request.auth.uid &&
        request.resource.data.primaryPatientId == resource.data.primaryPatientId;

      // Read: Device owner and linked caregivers can read the device
      allow read: if isSignedIn() && 
        (resource.data.primaryPatientId == request.auth.uid ||
         isLinkedToDevice(deviceId, request.auth.uid) ||
         request.auth.uid in (resource.data.linkedUsers.keys() || []));

      // Delete: Only device owner can delete
      allow delete: if isSignedIn() && 
        resource.data.primaryPatientId == request.auth.uid;
    }

    // deviceLinks: relationships between devices and users.
    // SIMPLIFIED RULES - Allow authenticated users to manage their own links
    match /deviceLinks/{linkId} {
      // Read: Any authenticated user can read deviceLinks
      allow read: if isSignedIn();

      // Create: Any authenticated user can create deviceLinks
      // Validation is done at the application level
      allow create: if isSignedIn();

      // Update: Any authenticated user can update deviceLinks
      allow update: if isSignedIn();

      // Delete: Any authenticated user can delete deviceLinks
      allow delete: if isSignedIn();
    }

    // deviceConfigs: configuration per device. Only users linked to the device may read/write.
    match /deviceConfigs/{deviceId} {
      // SIMPLIFIED for new user provisioning
      // Any authenticated user can create/read/update/delete device configs
      // Application logic ensures proper ownership
      allow read, write: if isSignedIn();
    }

    // medicationEvents: events generated when medications are created/updated/deleted or doses are taken.
    // Both patients and caregivers can read events they're associated with.
    // Both patients and caregivers can create events for medications they manage.
    match /medicationEvents/{eventId} {

      // Helper function to check if the request is within rate limit
      // Note: This is a simplified check. For production, consider using Cloud Functions
      // to enforce rate limiting more accurately, as Firestore rules have query limitations.
      function isWithinRateLimit() {
        // Rate limiting in security rules is limited due to query constraints.
        // This function serves as a placeholder for the rate limit logic.
        // Actual enforcement should be done via Cloud Functions or client-side throttling.
        // For now, we allow the operation and rely on monitoring.
        return true;
      }

      // Helper function to validate event data structure
      function isValidEventData() {
        let data = request.resource.data;
        return data.keys().hasAll(['eventType', 'medicationId', 'medicationName', 'patientId', 'timestamp', 'syncStatus']) &&
               data.eventType in ['medication_created', 'medication_updated', 'medication_deleted', 'dose_taken', 'dose_missed'] &&
               data.medicationId is string &&
               data.medicationName is string &&
               data.patientId is string &&
               data.timestamp is timestamp &&
               data.syncStatus in ['pending', 'synced', 'failed'] &&
               // Ensure the authenticated user is either the patient or has caregiverId field matching
               (data.patientId == request.auth.uid || 
                (data.keys().hasAny(['caregiverId']) && data.caregiverId == request.auth.uid)) &&
               // Validate optional fields
               (!data.keys().hasAny(['medicationData']) || data.medicationData is map) &&
               (!data.keys().hasAny(['changes']) || data.changes is list) &&
               (!data.keys().hasAny(['caregiverId']) || data.caregiverId is string) &&
               (!data.keys().hasAny(['patientName']) || data.patientName is string);
      }

      // Read access: patient can read their own events, any caregiver can read events
      allow read: if isSignedIn() && 
        (resource.data.patientId == request.auth.uid ||
         isCaregiver());

      // Create access: authenticated users can create events for medications they're associated with
      allow create: if isSignedIn() && 
        isValidEventData() &&
        isWithinRateLimit();

      // Update access: patient or any caregiver can update events
      allow update: if isSignedIn() && 
        (resource.data.patientId == request.auth.uid ||
         isCaregiver());

      // Delete access: patient or any caregiver can delete events
      allow delete: if isSignedIn() && 
        (resource.data.patientId == request.auth.uid ||
         isCaregiver());
    }

    // connectionCodes: time-limited codes for caregiver device linking.
    // Enhanced rules for device provisioning:
    // - Patients can create codes for their devices
    // - Authenticated users can read codes for validation
    // - Authenticated users can mark codes as used (one-time use only)
    // - Patients can delete their own codes
    // - Prevent code reuse
    match /connectionCodes/{code} {
      // Helper function to check if user owns the device
      function ownsDevice(deviceId) {
        return exists(/databases/$(database)/documents/devices/$(deviceId)) &&
               get(/databases/$(database)/documents/devices/$(deviceId)).data.primaryPatientId == request.auth.uid;
      }

      // Helper function to validate connection code data structure
      function isValidConnectionCodeData() {
        let data = request.resource.data;
        return data.keys().hasAll(['id', 'deviceId', 'patientId', 'patientName', 'createdAt', 'expiresAt', 'used']) &&
               data.id is string &&
               data.id.size() >= 6 && data.id.size() <= 8 &&
               data.deviceId is string &&
               data.patientId is string &&
               data.patientName is string &&
               data.createdAt is timestamp &&
               data.expiresAt is timestamp &&
               data.used == false && // New codes must start as unused
               // Ensure the authenticated user is the patient creating the code
               data.patientId == request.auth.uid &&
               // Validate optional fields
               (!data.keys().hasAny(['usedBy']) || data.usedBy is string) &&
               (!data.keys().hasAny(['usedAt']) || data.usedAt is timestamp);
      }

      // Helper function to validate code usage update (prevent reuse)
      function isValidCodeUsage() {
        let data = request.resource.data;
        // Code must not already be used (prevent reuse)
        return !resource.data.used &&
               // Must be marking as used
               data.used == true &&
               // Must include usedBy field with current user
               data.keys().hasAny(['usedBy']) &&
               data.usedBy == request.auth.uid &&
               // Must include usedAt timestamp
               data.keys().hasAny(['usedAt']) &&
               data.usedAt is timestamp &&
               // Cannot change other fields during usage
               data.id == resource.data.id &&
               data.deviceId == resource.data.deviceId &&
               data.patientId == resource.data.patientId &&
               data.patientName == resource.data.patientName &&
               data.createdAt == resource.data.createdAt &&
               data.expiresAt == resource.data.expiresAt;
      }

      // Read access: any authenticated user can read codes (needed for validation)
      allow read: if isSignedIn();

      // Create access: only patients can create codes for their devices
      allow create: if isSignedIn() && 
        request.resource.data.patientId == request.auth.uid &&
        request.resource.data.used == false;

      // Update access: authenticated users can mark codes as used (one-time use only)
      // Only the patient who created the code can update other fields
      // Prevent code reuse by checking if already used
      allow update: if isSignedIn() && 
        (isValidCodeUsage() || 
         (resource.data.patientId == request.auth.uid));

      // Delete access: only the patient who created the code can delete it (revoke)
      allow delete: if isSignedIn() && 
        resource.data.patientId == request.auth.uid;
    }

    // criticalEvents: critical event notifications for caregivers.
    // Caregivers can read events assigned to them.
    // System (via Cloud Functions) can create events.
    // Caregivers can update events to mark as read.
    match /criticalEvents/{eventId} {
      // Helper function to validate critical event data structure
      function isValidCriticalEventData() {
        let data = request.resource.data;
        return data.keys().hasAll(['eventType', 'patientId', 'patientName', 'message', 'severity', 'timestamp', 'caregiverId', 'read', 'notificationSent']) &&
               data.eventType in ['dose_missed', 'device_offline', 'low_battery', 'medication_deleted', 'inventory_low', 'device_error'] &&
               data.patientId is string &&
               data.patientName is string &&
               data.message is string &&
               data.severity in ['high', 'medium', 'low'] &&
               data.timestamp is timestamp &&
               data.caregiverId is string &&
               data.read is bool &&
               data.notificationSent is bool &&
               // Validate optional fields
               (!data.keys().hasAny(['deviceId']) || data.deviceId is string) &&
               (!data.keys().hasAny(['medicationId']) || data.medicationId is string) &&
               (!data.keys().hasAny(['medicationName']) || data.medicationName is string);
      }

      // Read access: caregivers can read events assigned to them
      allow read: if isSignedIn() && 
        resource.data.caregiverId == request.auth.uid;

      // Create access: authenticated users can create critical events
      // In production, this should be restricted to Cloud Functions only
      allow create: if isSignedIn() && 
        isValidCriticalEventData();

      // Update access: caregivers can update events to mark as read or update notification status
      allow update: if isSignedIn() && 
        resource.data.caregiverId == request.auth.uid &&
        // Only allow updating read and notificationSent fields
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'notificationSent']);

      // Delete access: caregivers can delete their own events
      allow delete: if isSignedIn() && 
        resource.data.caregiverId == request.auth.uid;
    }

    // fallback: deny everything else by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
